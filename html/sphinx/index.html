<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>TFTPy &mdash; TFTPy 0.6.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="TFTPy 0.6.0 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">TFTPy 0.6.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tftpy">
<h1>TFTPy<a class="headerlink" href="#tftpy" title="Permalink to this headline">¶</a></h1>
<p>TFTPy is a pure python TFTP implementation.</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>
<div class="section" id="requirements">
<h1>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h1>
<p>Python 2.3+, I think. I haven&#8217;t tested in Python 2.3 in a while but it should
still work. Let me know if it doesn&#8217;t.</p>
</div>
<div class="section" id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h1>
<p>If you download the source distribution, you can simply use distutils to
install, via:</p>
<div class="highlight-python"><div class="highlight"><pre>python setup.py build
python setup.py install
</pre></div>
</div>
<p>Or, as this has been uploaded to pypi, you can use easy_install or pip:</p>
<div class="highlight-python"><div class="highlight"><pre>easy_install tftpy
pip install tftpy
</pre></div>
</div>
<p>Once installed you should have the sample client and server scripts in bin,
and you should be able to import the <cite>tftpy</cite> module.</p>
</div>
<div class="section" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h1>
<p>The simplest tftp client:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">tftpy</span>

<span class="n">client</span> <span class="o">=</span> <span class="n">tftpy</span><span class="o">.</span><span class="n">TftpClient</span><span class="p">(</span><span class="s">&#39;tftp.digitaltorque.ca&#39;</span><span class="p">,</span> <span class="mi">69</span><span class="p">)</span>
<span class="n">client</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="s">&#39;remote_filename&#39;</span><span class="p">,</span> <span class="s">&#39;local_filename&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The simplest tftp server:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">tftpy</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">tftpy</span><span class="o">.</span><span class="n">TftpServer</span><span class="p">(</span><span class="s">&#39;/tftpboot&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">69</span><span class="p">)</span>
</pre></div>
</div>
<p>See the sample client and server for slightly more complex examples.</p>
</div>
<div class="section" id="api-documentation">
<h1>API Documentation<a class="headerlink" href="#api-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="front-end-modules">
<h2>Front-end Modules<a class="headerlink" href="#front-end-modules" title="Permalink to this headline">¶</a></h2>
<p>These modules are the ones that you will need to use directly to implement a
TFTP client or server.</p>
<div class="section" id="module-tftpy">
<span id="the-tftpy-module"></span><h3>The <a class="reference internal" href="#module-tftpy" title="tftpy"><tt class="xref py py-mod docutils literal"><span class="pre">tftpy</span></tt></a> Module<a class="headerlink" href="#module-tftpy" title="Permalink to this headline">¶</a></h3>
<p>This library implements the tftp protocol, based on rfc 1350.
<a class="reference external" href="http://www.faqs.org/rfcs/rfc1350.html">http://www.faqs.org/rfcs/rfc1350.html</a>
At the moment it implements only a client class, but will include a server,
with support for variable block sizes.</p>
<p>As a client of tftpy, this is the only module that you should need to import
directly. The TftpClient and TftpServer classes can be reached through it.</p>
</div>
<div class="section" id="module-tftpy.TftpClient">
<span id="the-tftpclient-module"></span><h3>The <cite>TftpClient</cite> Module<a class="headerlink" href="#module-tftpy.TftpClient" title="Permalink to this headline">¶</a></h3>
<p>This module implements the TFTP Client functionality. Instantiate an
instance of the client, and then use its upload or download method. Logging is
performed via a standard logging object set in TftpShared.</p>
<dl class="class">
<dt id="tftpy.TftpClient.TftpClient">
<em class="property">class </em><tt class="descclassname">tftpy.TftpClient.</tt><tt class="descname">TftpClient</tt><big>(</big><em>host</em>, <em>port</em>, <em>options={}</em><big>)</big><a class="headerlink" href="#tftpy.TftpClient.TftpClient" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpPacketTypes.TftpSession" title="tftpy.TftpPacketTypes.TftpSession"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpPacketTypes.TftpSession</span></tt></a></p>
<p>This class is an implementation of a tftp client. Once instantiated, a
download can be initiated via the download() method, or an upload via the
upload() method.</p>
<dl class="method">
<dt id="tftpy.TftpClient.TftpClient.download">
<tt class="descname">download</tt><big>(</big><em>filename</em>, <em>output</em>, <em>packethook=None</em>, <em>timeout=5</em><big>)</big><a class="headerlink" href="#tftpy.TftpClient.TftpClient.download" title="Permalink to this definition">¶</a></dt>
<dd><p>This method initiates a tftp download from the configured remote
host, requesting the filename passed. It writes the file to output,
which can be a file-like object or a path to a local file. If a
packethook is provided, it must be a function that takes a single
parameter, which will be a copy of each DAT packet received in the
form of a TftpPacketDAT object. The timeout parameter may be used to
override the default SOCK_TIMEOUT setting, which is the amount of time
that the client will wait for a receive packet to arrive.</p>
<p>Note: If output is a hyphen, stdout is used.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpClient.TftpClient.upload">
<tt class="descname">upload</tt><big>(</big><em>filename</em>, <em>input</em>, <em>packethook=None</em>, <em>timeout=5</em><big>)</big><a class="headerlink" href="#tftpy.TftpClient.TftpClient.upload" title="Permalink to this definition">¶</a></dt>
<dd><p>This method initiates a tftp upload to the configured remote host,
uploading the filename passed. It reads the file from input, which
can be a file-like object or a path to a local file. If a packethook
is provided, it must be a function that takes a single parameter,
which will be a copy of each DAT packet sent in the form of a
TftpPacketDAT object. The timeout parameter may be used to override
the default SOCK_TIMEOUT setting, which is the amount of time that
the client will wait for a DAT packet to be ACKd by the server.</p>
<p>Note: If input is a hyphen, stdin is used.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tftpy.TftpServer">
<span id="the-tftpserver-module"></span><h3>The <cite>TftpServer</cite> Module<a class="headerlink" href="#module-tftpy.TftpServer" title="Permalink to this headline">¶</a></h3>
<p>This module implements the TFTP Server functionality. Instantiate an
instance of the server, and then run the listen() method to listen for client
requests. Logging is performed via a standard logging object set in
TftpShared.</p>
<dl class="class">
<dt id="tftpy.TftpServer.TftpServer">
<em class="property">class </em><tt class="descclassname">tftpy.TftpServer.</tt><tt class="descname">TftpServer</tt><big>(</big><em>tftproot='/tftpboot'</em>, <em>dyn_file_func=None</em><big>)</big><a class="headerlink" href="#tftpy.TftpServer.TftpServer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpPacketTypes.TftpSession" title="tftpy.TftpPacketTypes.TftpSession"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpPacketTypes.TftpSession</span></tt></a></p>
<p>This class implements a tftp server object. Run the listen() method to
listen for client requests.  It takes two optional arguments. tftproot is
the path to the tftproot directory to serve files from and/or write them
to. dyn_file_func is a callable that must return a file-like object to
read from during downloads. This permits the serving of dynamic
content.</p>
<dl class="method">
<dt id="tftpy.TftpServer.TftpServer.listen">
<tt class="descname">listen</tt><big>(</big><em>listenip=''</em>, <em>listenport=69</em>, <em>timeout=5</em><big>)</big><a class="headerlink" href="#tftpy.TftpServer.TftpServer.listen" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a server listening on the supplied interface and port. This
defaults to INADDR_ANY (all interfaces) and UDP port 69. You can also
supply a different socket timeout value, if desired.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpServer.TftpServer.stop">
<tt class="descname">stop</tt><big>(</big><em>now=False</em><big>)</big><a class="headerlink" href="#tftpy.TftpServer.TftpServer.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the server gracefully. Do not take any new transfers,
but complete the existing ones. If force is True, drop everything
and stop. Note, immediately will not interrupt the select loop, it
will happen when the server returns on ready data, or a timeout.
ie. SOCK_TIMEOUT</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="back-end-modules">
<h2>Back-end Modules<a class="headerlink" href="#back-end-modules" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-tftpy.TftpPacketFactory">
<span id="the-tftppacketfactory-module"></span><h3>The <cite>TftpPacketFactory</cite> Module<a class="headerlink" href="#module-tftpy.TftpPacketFactory" title="Permalink to this headline">¶</a></h3>
<p>This module implements the TftpPacketFactory class, which can take a binary
buffer, and return the appropriate TftpPacket object to represent it, via the
parse() method.</p>
<dl class="class">
<dt id="tftpy.TftpPacketFactory.TftpPacketFactory">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketFactory.</tt><tt class="descname">TftpPacketFactory</tt><a class="headerlink" href="#tftpy.TftpPacketFactory.TftpPacketFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class generates TftpPacket objects. It is responsible for parsing
raw buffers off of the wire and returning objects representing them, via
the parse() method.</p>
<dl class="method">
<dt id="tftpy.TftpPacketFactory.TftpPacketFactory.parse">
<tt class="descname">parse</tt><big>(</big><em>buffer</em><big>)</big><a class="headerlink" href="#tftpy.TftpPacketFactory.TftpPacketFactory.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is used to parse an existing datagram into its
corresponding TftpPacket object. The buffer is the raw bytes off of
the network.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tftpy.TftpPacketTypes">
<span id="the-tftppackettypes-module"></span><h3>The <cite>TftpPacketTypes</cite> Module<a class="headerlink" href="#module-tftpy.TftpPacketTypes" title="Permalink to this headline">¶</a></h3>
<p>This module implements the packet types of TFTP itself, and the
corresponding encode and decode methods for them.</p>
<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacket">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacket</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class is the parent class of all tftp packet classes. It is an
abstract class, providing an interface, and should not be instantiated
directly.</p>
<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacket.decode">
<tt class="descname">decode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacket.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>The decode method of a TftpPacket takes a buffer off of the wire in
network-byte order, and decodes it, populating internal properties as
appropriate. This can only be done once the first 2-byte opcode has
already been decoded, but the data section does include the entire
datagram.</p>
<p>This is an abstract method.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacket.encode">
<tt class="descname">encode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacket.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>The encode method of a TftpPacket takes keyword arguments specific
to the type of packet, and packs an appropriate buffer in network-byte
order suitable for sending over the wire.</p>
<p>This is an abstract method.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketACK">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketACK</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketACK" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpPacketTypes.TftpPacket" title="tftpy.TftpPacketTypes.TftpPacket"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpPacketTypes.TftpPacket</span></tt></a></p>
<div class="highlight-python"><div class="highlight"><pre>        2 bytes    2 bytes
        -------------------
ACK   | 04    |   Block #  |
        --------------------
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketDAT">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketDAT</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketDAT" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpPacketTypes.TftpPacket" title="tftpy.TftpPacketTypes.TftpPacket"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpPacketTypes.TftpPacket</span></tt></a></p>
<div class="highlight-python"><div class="highlight"><pre>        2 bytes    2 bytes       n bytes
        ---------------------------------
DATA  | 03    |   Block #  |    Data    |
        ---------------------------------
</pre></div>
</div>
<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketDAT.decode">
<tt class="descname">decode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketDAT.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode self.buffer into instance variables. It returns self for
easy method chaining.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketDAT.encode">
<tt class="descname">encode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketDAT.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode the DAT packet. This method populates self.buffer, and
returns self for easy method chaining.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketERR">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketERR</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketERR" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpPacketTypes.TftpPacket" title="tftpy.TftpPacketTypes.TftpPacket"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpPacketTypes.TftpPacket</span></tt></a></p>
<div class="highlight-python"><div class="highlight"><pre>        2 bytes  2 bytes        string    1 byte
        ----------------------------------------
ERROR | 05    |  ErrorCode |   ErrMsg   |   0  |
        ----------------------------------------

Error Codes

Value     Meaning

0         Not defined, see error message (if any).
1         File not found.
2         Access violation.
3         Disk full or allocation exceeded.
4         Illegal TFTP operation.
5         Unknown transfer ID.
6         File already exists.
7         No such user.
8         Failed to negotiate options
</pre></div>
</div>
<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketERR.decode">
<tt class="descname">decode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketERR.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode self.buffer, populating instance variables and return self.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketERR.encode">
<tt class="descname">encode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketERR.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode the DAT packet based on instance variables, populating
self.buffer, returning self.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketInitial">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketInitial</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketInitial" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpPacketTypes.TftpPacket" title="tftpy.TftpPacketTypes.TftpPacket"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpPacketTypes.TftpPacket</span></tt></a>, <a class="reference internal" href="#tftpy.TftpPacketTypes.TftpPacketWithOptions" title="tftpy.TftpPacketTypes.TftpPacketWithOptions"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpPacketTypes.TftpPacketWithOptions</span></tt></a></p>
<p>This class is a common parent class for the RRQ and WRQ packets, as
they share quite a bit of code.</p>
<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketInitial.encode">
<tt class="descname">encode</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketInitial.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode the packet&#8217;s buffer from the instance variables.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketOACK">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketOACK</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketOACK" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpPacketTypes.TftpPacket" title="tftpy.TftpPacketTypes.TftpPacket"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpPacketTypes.TftpPacket</span></tt></a>, <a class="reference internal" href="#tftpy.TftpPacketTypes.TftpPacketWithOptions" title="tftpy.TftpPacketTypes.TftpPacketWithOptions"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpPacketTypes.TftpPacketWithOptions</span></tt></a></p>
<div class="highlight-python"><div class="highlight"><pre>+-------+---~~---+---+---~~---+---+---~~---+---+---~~---+---+
|  opc  |  opt1  | 0 | value1 | 0 |  optN  | 0 | valueN | 0 |
+-------+---~~---+---+---~~---+---+---~~---+---+---~~---+---+
</pre></div>
</div>
<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketOACK.match_options">
<tt class="descname">match_options</tt><big>(</big><em>options</em><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketOACK.match_options" title="Permalink to this definition">¶</a></dt>
<dd><p>This method takes a set of options, and tries to match them with
its own. It can accept some changes in those options from the server as
part of a negotiation. Changed or unchanged, it will return a dict of
the options so that the session can update itself to the negotiated
options.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketRRQ">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketRRQ</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketRRQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpPacketTypes.TftpPacketInitial" title="tftpy.TftpPacketTypes.TftpPacketInitial"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpPacketTypes.TftpPacketInitial</span></tt></a></p>
<div class="highlight-python"><div class="highlight"><pre>        2 bytes    string   1 byte     string   1 byte
        -----------------------------------------------
RRQ/  | 01/02 |  Filename  |   0  |    Mode    |   0  |
WRQ     -----------------------------------------------
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketWRQ">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketWRQ</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketWRQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpPacketTypes.TftpPacketInitial" title="tftpy.TftpPacketTypes.TftpPacketInitial"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpPacketTypes.TftpPacketInitial</span></tt></a></p>
<div class="highlight-python"><div class="highlight"><pre>        2 bytes    string   1 byte     string   1 byte
        -----------------------------------------------
RRQ/  | 01/02 |  Filename  |   0  |    Mode    |   0  |
WRQ     -----------------------------------------------
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpPacketWithOptions">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpPacketWithOptions</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketWithOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class exists to permit some TftpPacket subclasses to share code
regarding options handling. It does not inherit from TftpPacket, as the
goal is just to share code here, and not cause diamond inheritance.</p>
<dl class="method">
<dt id="tftpy.TftpPacketTypes.TftpPacketWithOptions.decode_options">
<tt class="descname">decode_options</tt><big>(</big><em>buffer</em><big>)</big><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpPacketWithOptions.decode_options" title="Permalink to this definition">¶</a></dt>
<dd><p>This method decodes the section of the buffer that contains an
unknown number of options. It returns a dictionary of option names and
values.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpPacketTypes.TftpSession">
<em class="property">class </em><tt class="descclassname">tftpy.TftpPacketTypes.</tt><tt class="descname">TftpSession</tt><a class="headerlink" href="#tftpy.TftpPacketTypes.TftpSession" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class is the base class for the tftp client and server. Any shared
code should be in this class.</p>
</dd></dl>

</div>
<div class="section" id="module-tftpy.TftpShared">
<span id="the-tftpshared-module"></span><h3>The <cite>TftpShared</cite> Module<a class="headerlink" href="#module-tftpy.TftpShared" title="Permalink to this headline">¶</a></h3>
<p>This module holds all objects shared by all other modules in tftpy.</p>
<dl class="class">
<dt id="tftpy.TftpShared.TftpErrors">
<em class="property">class </em><tt class="descclassname">tftpy.TftpShared.</tt><tt class="descname">TftpErrors</tt><a class="headerlink" href="#tftpy.TftpShared.TftpErrors" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class is a convenience for defining the common tftp error codes,
and making them more readable in the code.</p>
</dd></dl>

<dl class="exception">
<dt id="tftpy.TftpShared.TftpException">
<em class="property">exception </em><tt class="descclassname">tftpy.TftpShared.</tt><tt class="descname">TftpException</tt><a class="headerlink" href="#tftpy.TftpShared.TftpException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
<p>This class is the parent class of all exceptions regarding the handling
of the TFTP protocol.</p>
</dd></dl>

<dl class="exception">
<dt id="tftpy.TftpShared.TftpTimeout">
<em class="property">exception </em><tt class="descclassname">tftpy.TftpShared.</tt><tt class="descname">TftpTimeout</tt><a class="headerlink" href="#tftpy.TftpShared.TftpTimeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpShared.TftpException" title="tftpy.TftpShared.TftpException"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpShared.TftpException</span></tt></a></p>
<p>This class represents a timeout error waiting for a response from the
other end.</p>
</dd></dl>

<dl class="function">
<dt id="tftpy.TftpShared.setLogLevel">
<tt class="descclassname">tftpy.TftpShared.</tt><tt class="descname">setLogLevel</tt><big>(</big><em>level</em><big>)</big><a class="headerlink" href="#tftpy.TftpShared.setLogLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is a utility function for setting the internal log level.
The log level defaults to logging.NOTSET, so unwanted output to stdout is
not created.</p>
</dd></dl>

<dl class="function">
<dt id="tftpy.TftpShared.tftpassert">
<tt class="descclassname">tftpy.TftpShared.</tt><tt class="descname">tftpassert</tt><big>(</big><em>condition</em>, <em>msg</em><big>)</big><a class="headerlink" href="#tftpy.TftpShared.tftpassert" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is a simple utility that will check the condition
passed for a false state. If it finds one, it throws a TftpException
with the message passed. This just makes the code throughout cleaner
by refactoring.</p>
</dd></dl>

</div>
<div class="section" id="module-tftpy.TftpContexts">
<span id="the-tftpcontexts-module"></span><h3>The <cite>TftpContexts</cite> Module<a class="headerlink" href="#module-tftpy.TftpContexts" title="Permalink to this headline">¶</a></h3>
<p>This module implements all contexts for state handling during uploads and
downloads, the main interface to which being the TftpContext base class.</p>
<p>The concept is simple. Each context object represents a single upload or
download, and the state object in the context object represents the current
state of that transfer. The state object has a handle() method that expects
the next packet in the transfer, and returns a state object until the transfer
is complete, at which point it returns None. That is, unless there is a fatal
error, in which case a TftpException is returned instead.</p>
<dl class="class">
<dt id="tftpy.TftpContexts.TftpContext">
<em class="property">class </em><tt class="descclassname">tftpy.TftpContexts.</tt><tt class="descname">TftpContext</tt><big>(</big><em>host</em>, <em>port</em>, <em>timeout</em><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The base class of the contexts.</p>
<dl class="method">
<dt id="tftpy.TftpContexts.TftpContext.checkTimeout">
<tt class="descname">checkTimeout</tt><big>(</big><em>now</em><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContext.checkTimeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare current time with last_update time, and raise an exception
if we&#8217;re over the timeout time.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpContexts.TftpContext.cycle">
<tt class="descname">cycle</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContext.cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Here we wait for a response from the server after sending it
something, and dispatch appropriate action to that response.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpContexts.TftpContext.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContext.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform session cleanup, since the end method should always be
called explicitely by the calling code, this works better than the
destructor.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpContexts.TftpContext.getBlocksize">
<tt class="descname">getBlocksize</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContext.getBlocksize" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch the current blocksize for this session.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpContexts.TftpContext.gethost">
<tt class="descname">gethost</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContext.gethost" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple getter method for use in a property.</p>
</dd></dl>

<dl class="attribute">
<dt id="tftpy.TftpContexts.TftpContext.host">
<tt class="descname">host</tt><a class="headerlink" href="#tftpy.TftpContexts.TftpContext.host" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple getter method for use in a property.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpContexts.TftpContext.sethost">
<tt class="descname">sethost</tt><big>(</big><em>host</em><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContext.sethost" title="Permalink to this definition">¶</a></dt>
<dd><p>Setter method that also sets the address property as a result
of the host that is set.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpContexts.TftpContextClientDownload">
<em class="property">class </em><tt class="descclassname">tftpy.TftpContexts.</tt><tt class="descname">TftpContextClientDownload</tt><big>(</big><em>host</em>, <em>port</em>, <em>filename</em>, <em>output</em>, <em>options</em>, <em>packethook</em>, <em>timeout</em><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContextClientDownload" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpContexts.TftpContext" title="tftpy.TftpContexts.TftpContext"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpContexts.TftpContext</span></tt></a></p>
<p>The download context for the client during a download.
Note: If output is a hyphen, then the output will be sent to stdout.</p>
<dl class="method">
<dt id="tftpy.TftpContexts.TftpContextClientDownload.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContextClientDownload.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Finish up the context.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpContexts.TftpContextClientDownload.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContextClientDownload.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Initiate the download.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpContexts.TftpContextClientUpload">
<em class="property">class </em><tt class="descclassname">tftpy.TftpContexts.</tt><tt class="descname">TftpContextClientUpload</tt><big>(</big><em>host</em>, <em>port</em>, <em>filename</em>, <em>input</em>, <em>options</em>, <em>packethook</em>, <em>timeout</em><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContextClientUpload" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpContexts.TftpContext" title="tftpy.TftpContexts.TftpContext"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpContexts.TftpContext</span></tt></a></p>
<p>The upload context for the client during an upload.
Note: If input is a hyphen, then we will use stdin.</p>
<dl class="method">
<dt id="tftpy.TftpContexts.TftpContextClientUpload.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContextClientUpload.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Finish up the context.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpContexts.TftpContextServer">
<em class="property">class </em><tt class="descclassname">tftpy.TftpContexts.</tt><tt class="descname">TftpContextServer</tt><big>(</big><em>host</em>, <em>port</em>, <em>timeout</em>, <em>root</em>, <em>dyn_file_func=None</em><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContextServer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpContexts.TftpContext" title="tftpy.TftpContexts.TftpContext"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpContexts.TftpContext</span></tt></a></p>
<p>The context for the server.</p>
<dl class="method">
<dt id="tftpy.TftpContexts.TftpContextServer.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContextServer.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Finish up the context.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpContexts.TftpContextServer.start">
<tt class="descname">start</tt><big>(</big><em>buffer</em><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpContextServer.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the state cycle. Note that the server context receives an
initial packet in its start method. Also note that the server does not
loop on cycle(), as it expects the TftpServer object to manage
that.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpContexts.TftpMetrics">
<em class="property">class </em><tt class="descclassname">tftpy.TftpContexts.</tt><tt class="descname">TftpMetrics</tt><a class="headerlink" href="#tftpy.TftpContexts.TftpMetrics" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A class representing metrics of the transfer.</p>
<dl class="method">
<dt id="tftpy.TftpContexts.TftpMetrics.add_dup">
<tt class="descname">add_dup</tt><big>(</big><em>pkt</em><big>)</big><a class="headerlink" href="#tftpy.TftpContexts.TftpMetrics.add_dup" title="Permalink to this definition">¶</a></dt>
<dd><p>This method adds a dup for a packet to the metrics.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tftpy.TftpStates">
<span id="the-tftpstates-module"></span><h3>The <cite>TftpStates</cite> Module<a class="headerlink" href="#module-tftpy.TftpStates" title="Permalink to this headline">¶</a></h3>
<p>This module implements all state handling during uploads and downloads, the
main interface to which being the TftpState base class.</p>
<p>The concept is simple. Each context object represents a single upload or
download, and the state object in the context object represents the current
state of that transfer. The state object has a handle() method that expects
the next packet in the transfer, and returns a state object until the transfer
is complete, at which point it returns None. That is, unless there is a fatal
error, in which case a TftpException is returned instead.</p>
<dl class="class">
<dt id="tftpy.TftpStates.TftpServerState">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpServerState</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpServerState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpStates.TftpState" title="tftpy.TftpStates.TftpState"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpStates.TftpState</span></tt></a></p>
<p>The base class for server states.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpServerState.serverInitial">
<tt class="descname">serverInitial</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpServerState.serverInitial" title="Permalink to this definition">¶</a></dt>
<dd><p>This method performs initial setup for a server context transfer,
put here to refactor code out of the TftpStateServerRecvRRQ and
TftpStateServerRecvWRQ classes, since their initial setup is
identical. The method returns a boolean, sendoack, to indicate whether
it is required to send an OACK to the client.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpState">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpState</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The base class for the states.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpState.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract method for handling a packet. It is expected to return
a TftpState object, either itself or a new state.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.handleDat">
<tt class="descname">handleDat</tt><big>(</big><em>pkt</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.handleDat" title="Permalink to this definition">¶</a></dt>
<dd><p>This method handles a DAT packet during a client download, or a
server upload.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.handleOACK">
<tt class="descname">handleOACK</tt><big>(</big><em>pkt</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.handleOACK" title="Permalink to this definition">¶</a></dt>
<dd><p>This method handles an OACK from the server, syncing any accepted
options.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.resendLast">
<tt class="descname">resendLast</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.resendLast" title="Permalink to this definition">¶</a></dt>
<dd><p>Resend the last sent packet due to a timeout.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.returnSupportedOptions">
<tt class="descname">returnSupportedOptions</tt><big>(</big><em>options</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.returnSupportedOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>This method takes a requested options list from a client, and
returns the ones that are supported.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.sendACK">
<tt class="descname">sendACK</tt><big>(</big><em>blocknumber=None</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.sendACK" title="Permalink to this definition">¶</a></dt>
<dd><p>This method sends an ack packet to the block number specified. If
none is specified, it defaults to the next_block property in the
parent context.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.sendDAT">
<tt class="descname">sendDAT</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.sendDAT" title="Permalink to this definition">¶</a></dt>
<dd><p>This method sends the next DAT packet based on the data in the
context. It returns a boolean indicating whether the transfer is
finished.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.sendError">
<tt class="descname">sendError</tt><big>(</big><em>errorcode</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.sendError" title="Permalink to this definition">¶</a></dt>
<dd><p>This method uses the socket passed, and uses the errorcode to
compose and send an error packet.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpState.sendOACK">
<tt class="descname">sendOACK</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpState.sendOACK" title="Permalink to this definition">¶</a></dt>
<dd><p>This method sends an OACK packet with the options from the current
context.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateExpectACK">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateExpectACK</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateExpectACK" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpStates.TftpState" title="tftpy.TftpStates.TftpState"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpStates.TftpState</span></tt></a></p>
<p>This class represents the state of the transfer when a DAT was just
sent, and we are waiting for an ACK from the server. This class is the
same one used by the client during the upload, and the server during the
download.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateExpectACK.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateExpectACK.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a packet, hopefully an ACK since we just sent a DAT.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateExpectDAT">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateExpectDAT</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateExpectDAT" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpStates.TftpState" title="tftpy.TftpStates.TftpState"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpStates.TftpState</span></tt></a></p>
<p>Just sent an ACK packet. Waiting for DAT.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateExpectDAT.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateExpectDAT.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle the packet in response to an ACK, which should be a DAT.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateSentRRQ">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateSentRRQ</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateSentRRQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpStates.TftpState" title="tftpy.TftpStates.TftpState"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpStates.TftpState</span></tt></a></p>
<p>Just sent an RRQ packet.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateSentRRQ.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateSentRRQ.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle the packet in response to an RRQ to the server.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateSentWRQ">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateSentWRQ</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateSentWRQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpStates.TftpState" title="tftpy.TftpStates.TftpState"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpStates.TftpState</span></tt></a></p>
<p>Just sent an WRQ packet for an upload.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateSentWRQ.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateSentWRQ.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a packet we just received.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateServerRecvRRQ">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateServerRecvRRQ</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateServerRecvRRQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpStates.TftpServerState" title="tftpy.TftpStates.TftpServerState"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpStates.TftpServerState</span></tt></a></p>
<p>This class represents the state of the TFTP server when it has just
received an RRQ packet.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateServerRecvRRQ.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateServerRecvRRQ.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle an initial RRQ packet as a server.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateServerRecvWRQ">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateServerRecvWRQ</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateServerRecvWRQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpStates.TftpServerState" title="tftpy.TftpStates.TftpServerState"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpStates.TftpServerState</span></tt></a></p>
<p>This class represents the state of the TFTP server when it has just
received a WRQ packet.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateServerRecvWRQ.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateServerRecvWRQ.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle an initial WRQ packet as a server.</p>
</dd></dl>

<dl class="method">
<dt id="tftpy.TftpStates.TftpStateServerRecvWRQ.make_subdirs">
<tt class="descname">make_subdirs</tt><big>(</big><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateServerRecvWRQ.make_subdirs" title="Permalink to this definition">¶</a></dt>
<dd><p>The purpose of this method is to, if necessary, create all of the
subdirectories leading up to the file to the written.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tftpy.TftpStates.TftpStateServerStart">
<em class="property">class </em><tt class="descclassname">tftpy.TftpStates.</tt><tt class="descname">TftpStateServerStart</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateServerStart" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tftpy.TftpStates.TftpState" title="tftpy.TftpStates.TftpState"><tt class="xref py py-class docutils literal"><span class="pre">tftpy.TftpStates.TftpState</span></tt></a></p>
<p>The start state for the server. This is a transitory state since at
this point we don&#8217;t know if we&#8217;re handling an upload or a download. We
will commit to one of them once we interpret the initial packet.</p>
<dl class="method">
<dt id="tftpy.TftpStates.TftpStateServerStart.handle">
<tt class="descname">handle</tt><big>(</big><em>pkt</em>, <em>raddress</em>, <em>rport</em><big>)</big><a class="headerlink" href="#tftpy.TftpStates.TftpStateServerStart.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a packet we just received.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">TFTPy</a></li>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#api-documentation">API Documentation</a><ul>
<li><a class="reference internal" href="#front-end-modules">Front-end Modules</a><ul>
<li><a class="reference internal" href="#module-tftpy">The <tt class="docutils literal"><span class="pre">tftpy</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-tftpy.TftpClient">The <cite>TftpClient</cite> Module</a></li>
<li><a class="reference internal" href="#module-tftpy.TftpServer">The <cite>TftpServer</cite> Module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#back-end-modules">Back-end Modules</a><ul>
<li><a class="reference internal" href="#module-tftpy.TftpPacketFactory">The <cite>TftpPacketFactory</cite> Module</a></li>
<li><a class="reference internal" href="#module-tftpy.TftpPacketTypes">The <cite>TftpPacketTypes</cite> Module</a></li>
<li><a class="reference internal" href="#module-tftpy.TftpShared">The <cite>TftpShared</cite> Module</a></li>
<li><a class="reference internal" href="#module-tftpy.TftpContexts">The <cite>TftpContexts</cite> Module</a></li>
<li><a class="reference internal" href="#module-tftpy.TftpStates">The <cite>TftpStates</cite> Module</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">TFTPy 0.6.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, Michael P. Soulier.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>